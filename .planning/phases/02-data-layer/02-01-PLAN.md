---
phase: 02-data-layer
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/data_handler.py
  - tests/test_data_handler.py
  - data/.gitkeep
autonomous: true

must_haves:
  truths:
    - "DataHandler.stream_bars() is a yield-generator that releases one MarketEvent per next() call"
    - "All float OHLCV values are converted to Decimal via string constructor at ingestion"
    - "Bars with volume == 0 are silently skipped and never emitted"
    - "CSV files are loaded via pandas and bars are emitted chronologically"
    - "analyze({}) with empty data does not crash — returns empty generator"
  artifacts:
    - path: "src/data_handler.py"
      provides: "DataHandler class with yield-generator, Decimal conversion, null-volume rejection"
      min_lines: 80
      contains: "yield MarketEvent"
    - path: "tests/test_data_handler.py"
      provides: "TDD tests for DataHandler: generator, Decimal, null-volume, CSV"
      min_lines: 100
      contains: "def test_"
    - path: "data/.gitkeep"
      provides: "Placeholder for data directory"
  key_links:
    - from: "src/data_handler.py"
      to: "src/events.py"
      via: "imports MarketEvent for yielding"
      pattern: "from src\\.events import MarketEvent"
    - from: "tests/test_data_handler.py"
      to: "src/data_handler.py"
      via: "imports DataHandler for testing"
      pattern: "from src\\.data_handler import DataHandler"
---

<objective>
Implement the core DataHandler class with a yield-generator pattern that emits one MarketEvent per bar, converts all float prices to Decimal at the ingestion boundary, rejects null-volume bars, and supports CSV loading. TDD approach.

Purpose: DataHandler is the data ingestion gateway for the entire EDA pipeline. It feeds MarketEvents into the EventQueue. The yield-generator pattern structurally prevents look-ahead bias.

Output: src/data_handler.py with DataHandler class, tests/test_data_handler.py with comprehensive TDD tests, data/ directory for local data files.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data directory and write failing DataHandler tests</name>
  <files>data/.gitkeep, tests/test_data_handler.py</files>
  <action>
1. Create `data/.gitkeep` (empty file) to ensure the data directory is tracked.

2. Create `tests/test_data_handler.py` with these test classes:

**Imports:**
```python
import pytest
import csv
import os
import tempfile
from datetime import datetime, timezone, timedelta
from decimal import Decimal
from pathlib import Path
from src.data_handler import DataHandler
from src.events import MarketEvent
```

**Helper: `create_test_csv(rows, filepath)`** — writes CSV with columns: Date,Open,High,Low,Close,Volume

**Fixtures:**
- `sample_csv(tmp_path)` — 5-bar CSV with realistic OHLCV data, returns filepath
- `csv_with_zero_volume(tmp_path)` — 5-bar CSV where bar 3 has volume=0, returns filepath
- `empty_csv(tmp_path)` — CSV with only header row, returns filepath

**TestDataHandlerGenerator** — 6 tests:
1. `test_stream_bars_returns_generator` — isinstance check for generator
2. `test_stream_bars_yields_market_events` — first yielded item is MarketEvent
3. `test_stream_bars_yields_one_at_a_time` — next() returns exactly one event
4. `test_stream_bars_chronological_order` — timestamps are non-decreasing
5. `test_stream_bars_correct_count` — 5-bar CSV yields exactly 5 events
6. `test_stream_bars_exhausts_cleanly` — StopIteration after all bars consumed

**TestDecimalConversion** — 5 tests:
1. `test_open_is_decimal` — `isinstance(event.open, Decimal)`
2. `test_high_is_decimal` — `isinstance(event.high, Decimal)`
3. `test_low_is_decimal` — `isinstance(event.low, Decimal)`
4. `test_close_is_decimal` — `isinstance(event.close, Decimal)`
5. `test_decimal_precision_preserved` — CSV value "123.45" becomes exactly `Decimal('123.45')`, not float approximation

**TestNullVolumeRejection** — 3 tests (TEST-05):
1. `test_zero_volume_bars_skipped` — 5-bar CSV with 1 zero-volume bar yields exactly 4 events
2. `test_zero_volume_never_emitted` — all emitted events have volume > 0
3. `test_all_zero_volume_yields_nothing` — CSV where all bars have volume=0 yields 0 events

**TestCSVLoading** — 4 tests:
1. `test_loads_csv_file` — DataHandler("AAPL", csv_path=filepath) works
2. `test_symbol_set_correctly` — all emitted events have correct symbol
3. `test_timeframe_set_correctly` — all emitted events have correct timeframe
4. `test_empty_csv_yields_nothing` — empty CSV yields 0 events
5. `test_nonexistent_file_raises` — FileNotFoundError for missing file

Run tests — they MUST fail (RED phase).
  </action>
  <verify>
Run: `pytest tests/test_data_handler.py -v 2>&1 | head -30` — must show failures/errors.
  </verify>
  <done>19 failing tests written. TDD RED phase complete.</done>
</task>

<task type="auto">
  <name>Task 2: Implement DataHandler (GREEN phase)</name>
  <files>src/data_handler.py</files>
  <action>
Create `src/data_handler.py`:

**Module docstring:**
```
"""
data_handler.py — Sequential bar-by-bar data ingestion for apex-backtest.

Uses yield-generator pattern: one MarketEvent per next() call.
Structurally prevents look-ahead bias — no future data accessible.

All float prices are converted to Decimal via string constructor at ingestion.
Zero-volume bars are silently skipped.
"""
```

**Imports:**
```python
from __future__ import annotations
from datetime import datetime
from decimal import Decimal
from pathlib import Path
from typing import Generator, Optional
import pandas as pd
from src.events import MarketEvent
```

**DataHandler class:**
```python
class DataHandler:
    def __init__(
        self,
        symbol: str,
        timeframe: str = "1d",
        csv_path: Optional[str | Path] = None,
    ) -> None:
        self._symbol = symbol
        self._timeframe = timeframe
        self._csv_path = Path(csv_path) if csv_path else None
        self._df: Optional[pd.DataFrame] = None

    @property
    def symbol(self) -> str:
        return self._symbol

    @property
    def timeframe(self) -> str:
        return self._timeframe

    def _load_csv(self) -> pd.DataFrame:
        if self._csv_path is None:
            raise ValueError("No data source configured — provide csv_path or use fetch()")
        if not self._csv_path.exists():
            raise FileNotFoundError(f"CSV file not found: {self._csv_path}")
        df = pd.read_csv(self._csv_path, parse_dates=["Date"])
        df = df.sort_values("Date").reset_index(drop=True)
        return df

    def stream_bars(self) -> Generator[MarketEvent, None, None]:
        """Yield MarketEvents one at a time. Skips zero-volume bars."""
        if self._df is None:
            self._df = self._load_csv()

        for _, row in self._df.iterrows():
            volume = int(row["Volume"])
            if volume == 0:
                continue  # DATA-08: reject null-volume bars

            yield MarketEvent(
                symbol=self._symbol,
                timestamp=pd.Timestamp(row["Date"]).to_pydatetime(),
                open=Decimal(str(row["Open"])),      # DATA-02: string constructor
                high=Decimal(str(row["High"])),
                low=Decimal(str(row["Low"])),
                close=Decimal(str(row["Close"])),
                volume=volume,
                timeframe=self._timeframe,
            )
```

**RULES:**
- `Decimal(str(value))` — ALWAYS string constructor, NEVER `Decimal(float)`
- yield-generator, not list return
- Skip volume==0 silently
- Sort by Date ascending before yielding (chronological order)
  </action>
  <verify>
Run: `pytest tests/test_data_handler.py -v --tb=short` — ALL tests must pass (GREEN phase).
  </verify>
  <done>DataHandler implemented. All tests pass. Yield-generator emits one MarketEvent per bar, Decimal conversion via string constructor, null-volume rejection works.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pytest tests/test_data_handler.py -v --tb=short` exits 0, all tests pass
- [ ] `pytest tests/ -v --tb=short` exits 0 (all project tests pass)
- [ ] DataHandler.stream_bars() is a generator (isinstance check)
- [ ] All prices are Decimal, not float
- [ ] Zero-volume bars are never emitted
- [ ] CSV is loaded and sorted chronologically
</verification>

<success_criteria>
- TDD cycle complete: RED -> GREEN
- src/data_handler.py with yield-generator pattern
- Decimal conversion at ingestion boundary
- Null-volume rejection
- 19+ passing tests in test_data_handler.py
- All existing tests still pass
</success_criteria>
