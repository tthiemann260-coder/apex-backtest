---
phase: 01-event-foundation
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/event_queue.py
  - tests/test_events.py
  - tests/test_causality.py
autonomous: true

must_haves:
  truths:
    - "EventQueue wraps collections.deque and processes events in strict FIFO order"
    - "100 enqueued events dequeue in identical insertion order"
    - "EventQueue rejects non-Event objects with TypeError"
    - "test_causality.py skeleton exists with at least one passing test and is importable"
    - "pytest tests/ passes with zero warnings and zero failures"
  artifacts:
    - path: "src/event_queue.py"
      provides: "Central FIFO event queue wrapping collections.deque"
      min_lines: 40
      contains: "collections.deque"
      exports: ["EventQueue"]
    - path: "tests/test_causality.py"
      provides: "Causality test skeleton with placeholder tests for Phase 6"
      min_lines: 30
      contains: "TestCausalityInfrastructure"
  key_links:
    - from: "src/event_queue.py"
      to: "src/events.py"
      via: "imports Event types for type validation"
      pattern: "from src\\.events import"
    - from: "tests/test_events.py"
      to: "src/event_queue.py"
      via: "imports EventQueue for FIFO and type-rejection tests"
      pattern: "from src\\.event_queue import EventQueue"
    - from: "tests/test_causality.py"
      to: "src/events.py"
      via: "imports all event types for infrastructure check"
      pattern: "from src\\.events import"
    - from: "tests/test_causality.py"
      to: "src/event_queue.py"
      via: "imports EventQueue for causality precondition tests"
      pattern: "from src\\.event_queue import EventQueue"
---

<objective>
Implement the central FIFO EventQueue and write the full queue test suite plus the test_causality.py skeleton, using TDD (RED-GREEN-REFACTOR).

Purpose: The EventQueue is the backbone of the EDA pipeline — every component communicates through it. FIFO ordering is a correctness invariant. The causality test skeleton establishes the anti-lookahead-bias test infrastructure used in Phase 6.

Output: src/event_queue.py (EventQueue class), queue tests appended to tests/test_events.py, tests/test_causality.py skeleton with passing placeholder tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@CLAUDE.md
@.planning/phases/01-event-foundation/01-01-SUMMARY.md
</context>

<feature>
  <name>EventQueue — Central FIFO Event Queue</name>
  <files>src/event_queue.py, tests/test_events.py</files>
  <behavior>
  Expected behavior in testable terms:

  1. `EventQueue()` initializes empty — `is_empty()` returns True, `size()` returns 0, `len()` returns 0
  2. `put(event)` accepts valid Event instances (MarketEvent, SignalEvent, OrderEvent, FillEvent)
  3. `put(non_event)` raises TypeError with descriptive message for strings, ints, None, dicts
  4. `get()` returns events in FIFO order — first in, first out
  5. `get()` on empty queue raises IndexError
  6. 100 events enqueued then dequeued produce identical ordering
  7. Mixed event types maintain FIFO ordering
  8. `clear()` empties the queue completely
  9. `repr()` includes class name and size

  Cases:
  - put(MarketEvent) + get() -> same MarketEvent (identity check with `is`)
  - put(100 events) + get(100 times) -> identical list
  - put("string") -> TypeError
  - put(42) -> TypeError
  - put(None) -> TypeError
  - get() on empty -> IndexError
  </behavior>
  <implementation>
  EventQueue class wrapping collections.deque:
  - `_VALID_TYPES` class tuple: (MarketEvent, SignalEvent, OrderEvent, FillEvent)
  - `__init__`: creates `self._queue: deque[Event] = deque()`
  - `put(event)`: isinstance check against _VALID_TYPES, raises TypeError if invalid, appends to deque
  - `get()`: popleft from deque, raises IndexError if empty
  - `is_empty()`: returns `len(self._queue) == 0`
  - `size()`: returns `len(self._queue)`
  - `clear()`: calls `self._queue.clear()`
  - `__len__()`: returns `len(self._queue)`
  - `__repr__()`: returns `f"EventQueue(size={len(self._queue)})"`

  Thread-safety is NOT needed — single-threaded backtest loop assumed.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing EventQueue tests in tests/test_events.py</name>
  <files>tests/test_events.py</files>
  <action>
Append the following test class to the EXISTING `tests/test_events.py` file (created in Plan 01). Do NOT overwrite existing content — add after the last test class.

**Add import at the top of the file (after existing imports):**
```python
from src.event_queue import EventQueue
```

**Append test class:**

`TestEventQueue` — 11 tests covering:
1. `test_empty_on_init` — new queue is empty, size=0, len=0
2. `test_put_and_get_single_event` — put MarketEvent, get returns same instance (`is`), queue empty after
3. `test_fifo_ordering_100_events` — create 100 MarketEvents with unique symbols (`SYM{i:04d}`), enqueue all, dequeue all, assert `dequeued == events` (FIFO preserved)
4. `test_mixed_event_types_fifo` — put [market, signal, order, fill], get 4 times, assert same sequence
5. `test_get_raises_on_empty_queue` — `pytest.raises(IndexError)`
6. `test_put_rejects_string` — `pytest.raises(TypeError, match="EventQueue only accepts")`
7. `test_put_rejects_int` — `pytest.raises(TypeError)`
8. `test_put_rejects_none` — `pytest.raises(TypeError)`
9. `test_put_rejects_dict` — `pytest.raises(TypeError)` with `{"key": "value"}`
10. `test_clear_empties_queue` — put 2 events, clear, assert empty and size=0
11. `test_repr_contains_class_and_size` — assert "EventQueue" in repr, assert "size=0" in repr

Run tests BEFORE implementing EventQueue — they MUST fail (RED phase):
`pytest tests/test_events.py::TestEventQueue -v` — expect ImportError or collection errors.
  </action>
  <verify>
Run: `pytest tests/test_events.py::TestEventQueue -v 2>&1` — must show failures/errors (RED phase).
Run: `pytest tests/test_events.py -k "not EventQueue" -v` — existing tests from Plan 01 must still pass.
  </verify>
  <done>TestEventQueue class with 11 tests exists in test_events.py. Tests fail because src/event_queue.py does not exist yet. Existing Plan 01 tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement EventQueue in src/event_queue.py</name>
  <files>src/event_queue.py</files>
  <action>
Create `src/event_queue.py` with the following implementation:

**Module docstring:**
```
"""
event_queue.py — Central FIFO event queue for apex-backtest.

Wraps collections.deque to enforce strict FIFO ordering.
Accepts only valid Event instances (MarketEvent, SignalEvent, OrderEvent, FillEvent).
Thread-safety is NOT guaranteed — single-threaded backtest loop assumed.
"""
```

**Imports:**
```python
from __future__ import annotations
from collections import deque
from src.events import Event, MarketEvent, SignalEvent, OrderEvent, FillEvent
```

**EventQueue class** with exactly these methods:
- `_VALID_TYPES` class-level tuple: `(MarketEvent, SignalEvent, OrderEvent, FillEvent)`
- `__init__(self)`: `self._queue: deque[Event] = deque()`
- `put(self, event: Event) -> None`: isinstance check against `_VALID_TYPES`, raise `TypeError(f"EventQueue only accepts Event types ({[t.__name__ for t in self._VALID_TYPES]}), got {type(event).__name__!r}")` if invalid, else `self._queue.append(event)`
- `get(self) -> Event`: if queue non-empty return `self._queue.popleft()`, else raise `IndexError("EventQueue is empty — call is_empty() before get()")`
- `is_empty(self) -> bool`: `return len(self._queue) == 0`
- `size(self) -> int`: `return len(self._queue)`
- `clear(self) -> None`: `self._queue.clear()`
- `__len__(self) -> int`: `return len(self._queue)`
- `__repr__(self) -> str`: `return f"EventQueue(size={len(self._queue)})"`

After implementation, run ALL tests — they MUST pass (GREEN phase):
`pytest tests/test_events.py -v --tb=short`
  </action>
  <verify>
Run: `pytest tests/test_events.py -v --tb=short` — ALL tests (Plan 01 + EventQueue tests) must pass, zero warnings.
Run: `python -c "from src.event_queue import EventQueue; q = EventQueue(); print(repr(q))"` — must print `EventQueue(size=0)`.
  </verify>
  <done>EventQueue implemented. All tests in test_events.py pass (both existing event type tests and new EventQueue tests). EventQueue wraps collections.deque with FIFO ordering, type validation, and complete API.</done>
</task>

<task type="auto">
  <name>Task 3: Create test_causality.py skeleton with passing placeholder tests</name>
  <files>tests/test_causality.py</files>
  <action>
Create `tests/test_causality.py` as a skeleton for Phase 6 causality and temporal integrity tests.

**Module docstring:**
```
"""
test_causality.py — Causality and temporal integrity tests for apex-backtest.

PHASE 1 STATUS: Skeleton only. Placeholder tests pass to ensure
the module is importable and pytest-discoverable.

FULL CAUSALITY TESTS (Phase 6 — Engine Integration) will cover:
  - No SignalEvent timestamp precedes its generating MarketEvent timestamp
  - No OrderEvent timestamp precedes its generating SignalEvent timestamp
  - No FillEvent timestamp precedes its generating OrderEvent timestamp
  - EventQueue never produces events out of chronological order
  - No look-ahead bias: strategy cannot access bar[t+1] data at time t
  - Trade log entries are sorted by fill timestamp ascending
"""
```

**Imports:**
```python
import pytest
from datetime import datetime, timezone, timedelta
from decimal import Decimal
from src.events import (
    MarketEvent, SignalEvent, OrderEvent, FillEvent,
    OrderSide, SignalType, OrderType,
)
from src.event_queue import EventQueue
```

**Test class: `TestCausalityInfrastructure`** — 2 tests:

1. `test_placeholder_causality_module_importable` — asserts all event types and EventQueue are not None. This verifies the test infrastructure is importable.

2. `test_basic_timestamp_ordering_precondition` — creates a MarketEvent at t0 and a SignalEvent at t0 + 1 second. Asserts `signal.timestamp >= market.timestamp` with message "CAUSALITY VIOLATION: signal precedes market bar". This proves timestamp comparison works (prerequisite for Phase 6 full causality checks).

Both tests MUST pass immediately (they test infrastructure, not behavior that doesn't exist yet).
  </action>
  <verify>
Run: `pytest tests/test_causality.py -v --tb=short` — must exit 0, both tests pass.
Run: `pytest tests/ -v --tb=short` — ALL tests across both files pass, zero failures, zero warnings.
Run: `pytest tests/ -v --tb=short -q` — confirm "passed" in output, no "warning".
  </verify>
  <done>test_causality.py exists with 2 passing placeholder tests. Module is importable and pytest-discoverable. Causality test infrastructure is ready for Phase 6 expansion. Full test suite (test_events.py + test_causality.py) passes with zero warnings.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pytest tests/test_events.py -v --tb=short` exits 0, all tests pass (event types + EventQueue)
- [ ] `pytest tests/test_causality.py -v --tb=short` exits 0, placeholder tests pass
- [ ] `pytest tests/ -v --tb=short` exits 0, zero failures, zero warnings across all test files
- [ ] `python -c "from src.event_queue import EventQueue; q = EventQueue(); print(repr(q))"` prints `EventQueue(size=0)`
- [ ] FIFO test: 100 events enqueue+dequeue in identical order (covered by test_fifo_ordering_100_events)
- [ ] Type rejection: `EventQueue().put("string")` raises TypeError (covered by test_put_rejects_string)
</verification>

<success_criteria>
- TDD cycle complete: RED (failing tests) -> GREEN (passing implementation) -> tests green
- src/event_queue.py wraps collections.deque with FIFO ordering and type validation
- tests/test_events.py has 30+ total tests (Plan 01 event tests + Plan 02 queue tests)
- tests/test_causality.py has 2 passing placeholder tests
- `pytest tests/` passes with zero warnings, zero failures
- All Phase 1 success criteria from ROADMAP.md are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-event-foundation/01-02-SUMMARY.md`
</output>
