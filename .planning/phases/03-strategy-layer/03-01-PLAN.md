---
phase: 03-strategy-layer
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/strategy/__init__.py
  - src/strategy/base.py
  - tests/test_strategy.py
autonomous: true

must_haves:
  truths:
    - "BaseStrategy is abc.ABC — instantiating it directly raises TypeError"
    - "calculate_signals(event) is an abstract method returning Optional[SignalEvent]"
    - "Strategy maintains a rolling buffer of historical bars"
    - "Parameter injection works via __init__ kwargs"
  artifacts:
    - path: "src/strategy/base.py"
      provides: "Abstract BaseStrategy with rolling buffer and parameter injection"
      contains: "abc.ABC"
    - path: "tests/test_strategy.py"
      provides: "Tests for BaseStrategy abstraction and rolling buffer"
      contains: "test_"
---

<objective>
Create the abstract BaseStrategy class with rolling buffer for historical bars, parameter injection, and test infrastructure.

Purpose: BaseStrategy defines the contract all strategies must follow. The rolling buffer ensures strategies only see historical data (STRAT-08). Parameter injection enables configurable strategies (STRAT-07).

Output: src/strategy/base.py with BaseStrategy ABC, tests/test_strategy.py with 10+ tests.
</objective>

<tasks>

<task type="auto">
  <name>Task 1: Write BaseStrategy tests (RED)</name>
  <files>tests/test_strategy.py, src/strategy/__init__.py</files>
  <action>
Create `src/strategy/__init__.py` (empty).

Create `tests/test_strategy.py` with:

**TestBaseStrategyAbstraction** — 4 tests:
1. `test_base_strategy_is_abstract` — instantiating BaseStrategy raises TypeError
2. `test_concrete_strategy_instantiates` — subclass with calculate_signals works
3. `test_calculate_signals_returns_signal_or_none` — valid return types
4. `test_calculate_signals_receives_market_event` — correct event type

**TestRollingBuffer** — 4 tests:
1. `test_buffer_starts_empty` — no bars before any event
2. `test_buffer_grows_with_events` — buffer size increases with each bar
3. `test_buffer_respects_max_size` — oldest bars dropped when limit reached
4. `test_buffer_contains_only_past_bars` — no future data in buffer

**TestParameterInjection** — 3 tests:
1. `test_custom_params_stored` — params passed at init accessible
2. `test_default_params` — default values work
3. `test_params_immutable_during_run` — params don't change mid-run
  </action>
  <verify>Tests fail (RED phase).</verify>
  <done>11 failing tests written for BaseStrategy.</done>
</task>

<task type="auto">
  <name>Task 2: Implement BaseStrategy (GREEN)</name>
  <files>src/strategy/base.py</files>
  <action>
Create BaseStrategy ABC with:
- `abc.ABC` base class
- `@abstractmethod calculate_signals(self, event: MarketEvent) -> Optional[SignalEvent]`
- Rolling buffer: `self._bar_buffer: list[MarketEvent]` with configurable `max_buffer_size`
- `update_buffer(event)` method — appends event, trims to max size
- `@property bars` — returns copy of buffer (read-only)
- Parameter storage via `self._params: dict`
  </action>
  <verify>All tests pass (GREEN).</verify>
  <done>BaseStrategy implemented, all tests pass.</done>
</task>

</tasks>
